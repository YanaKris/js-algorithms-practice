# Управление памятью в JavaScript

В JavaScript управление памятью происходит автоматически, однако существуют некоторые способы ручного управления.

В JavaScript есть механизм сборки мусора (Garbage Collection), который автоматически отслеживает и удаляет объекты, которые больше не используются или на которые нет ссылок. Сборка мусора осуществляется регулярно, и ее алгоритмы оптимизированы для эффективного освобождения памяти. Однако, если в коде создаются циклические ссылки (когда объект A ссылается на объект B, а объект B ссылается на объект A), сборка мусора может столкнуться с проблемой. В таких случаях важно обеспечивать явное обнуление ссылок или использовать слабые ссылки (WeakMap, WeakSet), чтобы избежать утечек памяти.

Механизмы управления памятью, который использует сборщик мусора:

- Ссылочный подсчет (Reference Counting). Это один из методов сборки мусора, который подсчитывает количество ссылок на объект. Когда количество ссылок становится равным нулю, объект уничтожается. Однако этот метод неэффективен для обнаружения и очистки циклических ссылок.

- Метки времени жизни (Mark-and-Sweep). Этот метод основан на алгоритме «пометить и удалить». Сборщик мусора помечает все объекты, доступные из корневого узла (глобальные объекты, стек вызовов, замыкания), как активные, а затем удаляет не помеченные объекты. Этот метод эффективно обрабатывает циклические ссылки.

## Локальное управление памятью

- Существует оператор `delete`. Оператор delete используется для удаления свойств объекта. Однако он не освобождает память, а только удаляет свойство. Использование delete для удаления переменных может быть неэффективным и не рекомендуется.

- Присвоение переменной значения null или undefined является способом «ручного» освобождения памяти, если вы уверены, что объект больше не будет использоваться.

- Можно вручную вызвать сборщик мусора, но на практике обычно нет необходимости вручную вызывать его, нет гарантии, что память будет освобождена, т. к. механизм сборщика мусора сам решает, когда необходимо освободить память.

## Цикл памяти

Когда выполняется объявление переменной или создается функция, то память проходит следующий цикл:

1. Выделение памяти (Allocate). Движок выделяет память, которая требуется для созданного объекта.
2. Использование (Use). Это когда разработчик считывает и записывает данные в память.
3. Освобождение памяти (Release). После того, как резерв высвобожден, память можно использовать и для других целей.

## Где хранятся данные

В JavaScript данные хранятся в различных местах в зависимости от их типа и области видимости.

### Статическое выдыление памяти

Стек вызовов (Call Stack) используется для хранения контекстов выполнения функций. Когда функция вызывается, ее контекст помещается в вершину стека, и данные (локальные переменные и параметры) хранятся в этом контексте. Когда функция завершает выполнение, ее контекст удаляется из вершины стека. Это место хранения данных является временным и связано с выполнением функций.

### Динамическоее выделение памяти

Куча (Heap) используется для долгосрочного хранения данных, которые могут быть доступны из разных частей программы и существуют в течение более длительного времени. Это место хранения данных включает в себя объекты, массивы и другие сложные структуры данных. Объекты, созданные динамически в ходе выполнения программы, обычно располагаются в куче. Сборка мусора отвечает за освобождение памяти в куче, когда объектыбольше не используются. И, в отличие от стека, движок не может «знать», какой объем памяти необходим для того или иного объекта, поэтому память выделяется по мере необходимости. И этот способ выделения памяти называется «динамическим» (dynamic memory allocation).

## Возможные причины возникновения утечек памяти

В процессе разработки утечки памяти являются одним из неприятных явлений. Однако, зная наиболее распространенные причины утечек, можно избежать проблем сравнительно легко.

### Глобальные переменные

Утечки памяти часто происходят из-за хранения данных в глобальных переменных. В браузере, если использовать var в глобальной области видимости вместо const или let, переменная будет привязана к объекту window. Это также относится к функциям, определенным с использованием ключевого слова function.

```javascript
user = getUser();
var secondUser = getUser();
function getUser() {
  return 'user';
}
// user, secondUser, и getUser будут привязаны к объекту window.
```

Такое поведение применимо только к функциям и переменным, объявленным в глобальной области видимости. Проблему можно решить, используя строгий режим (strict mode).

```javascript
'use strict';
user = getUser();
var secondUser = getUser();
function getUser() {
  return 'user';
}
// user, secondUser, и getUser будут привязаны к объекту window.
```

### Функции обратного вызова и таймеры

Приложение может использовать больше памяти, чем необходимо, если забыть про таймеры и коллбеки, особенно в случае одностраничных приложений (SPA) и динамического добавления коллбеков и обработчиков событий.

```javascript
const object = {};
const intervalId = setInterval(function() {
  // Сборщик мусора не удалит объекты, используемые здесь,
  // пока интервал не будет очищен.
  doSomething(object);
}, 2000);

// Этот интервал должен быть очищен вовремя.
clearInterval(intervalId);
```

В примере выше объекты, на которые есть ссылка в интервале, не уничтожаются, пока интервал не будет очищен. Поэтому важно своевременно использовать clearInterval для очистки интервала.

```javascript
const element = document.getElementById('button');
const onClick = () => alert('hi');
element.addEventListener('click', onClick);
//element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
```

В примере выше если к кнопке привязан обработчик onClick, а сама кнопка удаляется после, может возникнуть проблема: кнопки нет, а слушатель для клика остался, поэтому надо не забывать удалять слушателей событий своевременно.

### DOM элементы

```javascript
const elements = [];
const element = document.getElementById('button');
elements.push(element);
function removeAllElements() {
  elements.forEach((item) => {
    document.body.removeChild(document.getElementById(item.id));
  });
}

// Удаление элемента также должно быть актуализировано в массиве.
const elements = [];
const element = document.getElementById('button');
elements.push(element);
function removeAllElements() {
  elements.forEach((item, index) => {
    document.body.removeChild(document.getElementById(item.id));
    elements.splice(index, 1);
  });
}
```

Проблема аналогична предыдущему случаю. Ошибка возникает, когда элементы DOM хранятся в переменной. Необходимо удалять элементы также из массива.
