# Управление памятью в JavaScript

В JavaScript управление памятью происходит автоматически, однако существуют некоторые способы ручного управления.

В JavaScript есть механизм сборки мусора (Garbage Collection), который автоматически отслеживает и удаляет объекты, которые больше не используются или на которые нет ссылок. Сборка мусора осуществляется регулярно, и ее алгоритмы оптимизированы для эффективного освобождения памяти. Однако, если в коде создаются циклические ссылки (когда объект A ссылается на объект B, а объект B ссылается на объект A), сборка мусора может столкнуться с проблемой. В таких случаях важно обеспечивать явное обнуление ссылок или использовать слабые ссылки (WeakMap, WeakSet), чтобы избежать утечек памяти.

Механизмы управления памятью, который использует сборщик мусора:

- Ссылочный подсчет (Reference Counting). Это один из методов сборки мусора, который подсчитывает количество ссылок на объект. Когда количество ссылок становится равным нулю, объект уничтожается. Однако этот метод неэффективен для обнаружения и очистки циклических ссылок.

- Метки времени жизни (Mark-and-Sweep). Этот метод основан на алгоритме "пометить и удалить". Сборщик мусора помечает все объекты, доступные из корневого узла (глобальные объекты, стек вызовов, замыкания) как активные, а затем удаляет не помеченные объекты. Этот метод эффективно обрабатывает циклические ссылки.

## Локальное управление памятью

- Существует оператор `delete`. Оператор delete используется для удаления свойств объекта. Однако он не освобождает память, а только удаляет свойство. Использование delete для удаления переменных может быть неэффективным и не рекомендуется.

- Присвоение переменной значения null или undefined является способом "ручного" освобождения памяти, если вы уверены, что объект больше не будет использоваться.

- Можно вручную вызвать сборщик мусора, но на практике обычно нет необходимости вручную вызывать его, нет гарантии, что память будет освобождена, т.к. механизм сборщика мусора сам решает, когда необходимо освободить память.

## Цикл памяти

Когда выполняется объявление переменной или создается функция, то память проходит следующий цикл:

1. Выделение памяти (Allocate). Движок выделяет память, которая требуется для созданного объекта.
2. Когда разработчик считывает и записывает данные в память - это использование (Use).
3. Освобождение памяти (Release).После того, как резерв высвобожден, память можно использовать и для других целей.

## Где хранятся данные

В JavaScript данные хранятся в различных местах в зависимости от их типа и области видимости.

### Статическое выдыление памяти

Стек вызовов (Call Stack) используется для хранения контекстов выполнения функций. Когда функция вызывается, ее контекст помещается в вершину стека, и данные (локальные переменные и параметры) хранятся в этом контексте. Когда функция завершает выполнение, ее контекст удаляется из вершины стека. Это место хранения данных является временным и связано с выполнением функций.

### Динамическоее выделение памяти

Куча (Heap) используется для долгосрочного хранения данных, которые могут быть доступны из разных частей программы и существуют в течение более длительного времени. Это место хранения данных включает в себя объекты, массивы и другие сложные структуры данных. Объекты, созданные динамически в ходе выполнения программы, обычно располагаются в куче. Сборка мусора отвечает за освобождение памяти в куче, когда объектыбольше не используются. И в отличие от стека движок не может «знать», какой объем памяти необходим для того либо иного объекта, поэтому память выделяется по мере необходимости. И этот способ выделения памяти называется «динамическим» (dynamic memory allocation).

## Возможные причины возникновения утечек памяти

В процессе разработки утечки памяти являются одним из неприятных явлений. Однако, зная наиболее распространенные причины утечек, можно избежать проблем сравнительно легко.

### Глобальные переменные

Утечки памяти часто происходят из-за хранения данных в глобальных переменных. В браузере, если использовать var в глобальной области видимости вместо const или let, переменная будет привязана к объекту window. Это также относится к функциям, определенным с использованием ключевого слова function.

```javascript
user = getUser();
var secondUser = getUser();
function getUser() {
  return 'user';
}
// user, secondUser, и getUser будут привязаны к объекту window.
```

Такое поведение применимо только к функциям и переменным, объявленным в глобальной области видимости. Проблему можно решить, используя строгий режим (strict mode).

```javascript
'use strict';
user = getUser();
var secondUser = getUser();
function getUser() {
  return 'user';
}
// user, secondUser, и getUser будут привязаны к объекту window.
```

### Функции обратного вызова и таймеры

Приложение может использовать больше памяти, чем необходимо, если забыть про таймеры и коллбеки, особенно в случае одностраничных приложений (SPA) и динамического добавления коллбеков и обработчиков событий.

```javascript
const object = {};
const intervalId = setInterval(function() {
  // Сборщик мусора не удалит объекты, используемые здесь,
  // пока интервал не будет очищен.
  doSomething(object);
}, 2000);

// Этот интервал должен быть очищен вовремя.
clearInterval(intervalId);
```

В примере выше, объекты, на которые есть ссылка в интервале, не уничтожаются, пока интервал не будет очищен. Поэтому важно своевременно использовать clearInterval для очистки интервала.

```javascript
const element = document.getElementById('button');
const onClick = () => alert('hi');
element.addEventListener('click', onClick);
//element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
```

в примере выше, Если к кнопке привязан обработчик onClick, а сама кнопка удаляется после, может возникнуть проблема: кнопки нет, а слушатель для клика остался, поэтому надо не забывать удалять слушатели событий своевременно.

### DOM элементы

```javascript
const elements = [];
const element = document.getElementById('button');
elements.push(element);
function removeAllElements() {
  elements.forEach((item) => {
    document.body.removeChild(document.getElementById(item.id));
  });
}

// Удаление элемента также должно быть актуализировано в массиве.
const elements = [];
const element = document.getElementById('button');
elements.push(element);
function removeAllElements() {
  elements.forEach((item, index) => {
    document.body.removeChild(document.getElementById(item.id));
    elements.splice(index, 1);
  });
}
```

Проблема аналогична предыдущему случаю. Ошибка возникает, когда элементы DOM хранятся в переменной. Необходимо удалять элементы также из массива.
