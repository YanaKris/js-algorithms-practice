# Темы

Типы данных: types.md

Управление памятью: memory.md

Функции и области видимости: functions.md

Управляющие структуры: management_structures.md

Ввод — вывод: stdio.md

Компиляция интерпретация: interpretation.md

Точка входа в программу, структура программы: entry_point.md

Обработка исключений: exceptions.md

Объектная модель документа (DOM): dom.md

Спецификация: specification.md

# Методические указания к заданиям

## Задание 1. Создание диапазона

Диапазон представляется в виде массива чисел. Внутри функции создаётся пустой массив. Далее используем любой вид цикла и итерируемся от начала диапазона до конца добавляя в массив числа. Возвращем заполненный массив.

## Задание 2. Поиск двух чисел, составляющих сумму

Для начала понадобиться создать словарь в виде объекта, или map-структуры. В словаре будет храниться текущее число в качестве ключа, а в качестве значения текущий индекс. Итерируемся по массиву, внутри цикла создаём временную переменую, в которой храниться разница суммы и текущуго числа из массива. проверяем, если в словаре есть запись, где в качестве ключа эта разница, то возвращаем кортеж: первый элемент значение из словаря по ключу разницы, а второй текущий индекс, иначе, записываем в словарь в качестве ключа — текущее число, а в качестве значения — текущий индекс.

#### Пример

Пусть дан массив [1,2,3,4,5,6] и целевая сумма = 6.

Итерация:

1. Разница = 6 - 1 = 5. В словаре нет значения по ключу 5, значит вносим запись, ключ = 1, значение = 0.

2. Разница = 6 - 2 = 4. В словаре нет записи по ключу 4, значит вносим запись, ключ = 2, значение = 1.

3. Разница = 6 - 3 = 3. В словаре нет записи по ключу 3, значит вносим запись, ключ = 3, значение = 2.

4. Разница = 6 - 4 = 2. В словаре есть запись по ключу 2, его значение равно = 1, значит возвращаем индексы [1 (индекс числа 2), 3 (индекс числа 4)].

## Задание 3. нахождение НОД

**_Алгоритм Евклида_** — это алгоритм для нахождения наибольшего общего делителя (НОД) двух неотрицательных целых чисел. НОД двух чисел — это наибольшее число, которое делит оба числа без остатка. Алгоритм был назван в честь древнегреческого математика Евклида.

$`НОД(a,b)=НОД(b,a mod (b))`$

mod — это операция целочисленного деления. Эта операция повторяется пока $`b \not = 0`$. Когда b становится равным 0, то текущее a становиться НОД(a,b).

### Пример

Рассмотрим нахождение НОД(48, 18) с использованием алгоритма Евклида:

1. Начальные значения a = 48, b = 18.
2. a = 18, b = 48 mod 18 = 12.
3. a = 12, b = 18 mod 12 = 6.
4. a = 6, b = 12 mod 6 = 0.

теперь b = 0, тогда НОД(48, 18) = 6.

Рассмотрим нахождение НОД(48, 18) с использованием алгоритма Евклида:

#### Шаги алгоритма

1. Если $`b = 0`$, то  $`НОД(a,b) = a`$.
2. Иначе заменить a на b, а b на $`a mod b`$, и вернуться к шагу 1.

## Задание 4. Нахождение простых чисел

Решето Эратосфена — это алгоритм для нахождения всех простых чисел до заданного целого числа **_n_**. Алгоритм исключает все составные числа последовательным отсеиванием. Этот алгоритм приписывают древнегреческому математику **_Эратосфену Киренскому_**.

### Алгоритм

Создаем указатель на опорное число, в начале оно равняется 2.

1. Удаляем числа из массива кратные текущему опорному числу (в начале оно равно 2).
2. Сместим указатель на следующее неудаленное число в массиве.
3. Повторяем шаги 1-2, пока не пройдем все числа в массиве.
4. Возвращаем массив с полученными числами.

#### Пример

Пусть дан массив [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20].

1. Опорное число = 2, после удаления чисел, кратных 2, массив будет: [2,3,5,7,9,11,13,15,17,19].
2. Смещаем указатель на число 3, удаляем числа, кратные 3: [2,3,5,7,11,13,17,19].
3. Смещаем указатель на число 5, удаляем числа, кратные 5:[2,3,5,7,11,13,17,19].

...

n. Получаем массив простых чисел [2,3,5,7,11,13,17,19].

## Задание 5. Запланированная встреча

Создаётся дата начала дня и дата конца. Даты выбираются в произвольном порядке. Формат времени равен 24 формату `hh:mm`.
Можно выделить из переданной строки часы и минуты с помощью регулярных выражений или строковых методов. Далее работать с этими датами в формате числа.

#### Пример

Начало дня 8:00, конец дня 18:00.
Встреча начинается в 10:00 длительностью 120 минут.
Функция должна возвратить `false`.

## Задание 6. Шифр цезаря

**_Шифр Цезаря (или шифр сдвига)_** — это простой метод шифрования, в котором каждая буква в тексте заменяется буквой, находящейся на постоянное число позиций вперёд в алфавите. Это шифрование получило своё название в честь римского полководца и императора Гая Юлия Цезаря, который, по преданию, использовал его для защиты своих личных сообщений.

В этом задании каждый символ не заменяется только на один другой символ, а заменяется на большее количество символов.

#### Пример

Дана строка abc, правило замены: a = bc, b = ac, c = ab. Количество замен = 2.

1. abc => bcacab
2. bcacab => acabbcabbcac

****Ответ:**** acabbcabbcac

## Задание 7. Скользящее среднее

**_Простое скользящее среднее (Simple moving average)_** — численно равно среднему арифметическому значений исходной функции за установленный период и вычисляется по формуле:

$`SMA_t = \frac{1}{n} \displaystyle\sum_{i=0}^{n-1} p_{t-i} = \frac{p_t + p_{t-1} + ... + p_{t-i} + ... + p_{t - n +2} + p_{t - n + 1}}{n},`$

где $`SMA_t - `$ значение простого скользящего среднего в точке $`t`$,

$`n`$ - количество значений исходной функции для расчёта скользящего среднего,

$`p_{t-i} - `$ — значение исходной функции в точке $`t - i`$.

Необходимо написать функцию, которая работает по такой формуле, учитывая граничные условия.

### Пример

Рассчитаем значения простого скользящего в точках для массива arr = [1,2,3,4], при $`n = 3`$.

1. arr[0] = 1 / 3 = 0.333
2. arr[1] = (1 + 2) / 3 = 1
3. arr[2] = (1 + 2 + 3) / 3 = 2
4. arr[3] = (2 + 3 + 4) / 3 = 3

**_Ответ:_** [0.333, 1, 2, 3].

## Задание 8. Сортировка слиянием

**_Сортировка слиянием_** — это эффективный и стабильный алгоритм сортировки, который применяет стратегию «разделяй и властвуй». Алгоритм разделяет массив на две равные части, рекурсивно сортирует каждую половину, а затем объединяет (сливает) две отсортированные половины в одну целую отсортированную последовательность.

### Алгоритм

1. Разделим исходный массив на две равные части.

2. Рекурсивно применим сортировку слиянием к каждой половине массива.

3. Объединим две отсортированные половины в новый временный массив.

4. Заменим исходный массив отсортированным массивом.

#### Пример

Рассмотрим сортировку слиянием на примере массива [38, 27, 43, 3, 9, 82, 10].

1. Разделим массив на две части: [38, 27, 43] и [3, 9, 82, 10].

2. Сортируем первую половину: [27, 38, 43]. Сортируем вторую половину: [3, 9, 10, 82].

3. Объединим отсортированные половины в новый временный массив:

- Первый массив: [27, 38, 43].
- Второй массив: [3, 9, 10, 82].
- Временный массив: [3, 9, 10, 27, 38, 43, 82].

4. Заменим исходный массив отсортированным массивом: [3, 9, 10, 27, 38, 43, 82].

## Задание 9. Бинарный поиск

**_Бинарный поиск_** — это эффективный алгоритм поиска в отсортированных массивах. Алгоритм основан на стратегии _разделяй и властвуй_ и позволяет быстро находить позицию заданного элемента в упорядоченном массиве.

### Алгоритм

1. Установим два указателя, левый (**_left_**) и правый (**_right_**), на границы исследуемой области массива. Изначально left указывает на начало массива, а right на конец массива.

2. Найдем средний (опорный) элемент массива, округляя вниз, если индекс среднего элемента не является целым числом. Средний элемент вычисляется как $`pivot = \frac{left + right}{2}`$

3. Сравним значение среднего элемента с целевым (искомым) элементом.

4. Если значение среднего элемента равно целевому (искомому) элементу, то искомый элемент найден, и алгоритм завершается.

5. Если значение среднего элемента больше целевого элемента, то уменьшим указатель left, чтобы сузить область поиска до левой половины.

6. Если значение среднего элемента меньше целевого элемента, увеличим указатель right, чтобы сузить область поиска до правой половины.

7. Повторяем шаги 2-4, пока не будет найден искомый элемент или область поиска не станет пустой.

#### Пример

Рассмотрим поиск элемента 43 в отсортированном массиве [3, 9, 10, 27, 38, 43, 82].

1. left = 0, right = 6.

2. pivot = (0 + 6) / 2 = 3 (индекс, это элемент 27).

3. 27 < 43.

4. Увеличиваем right до 4 (средний элемент 38).

5. Вычисляем новый pivot = 5 (элемент 43).

6. $`43 \equiv 43`$.

7. Найден искомый элемент 43, возвращаем его индекс (5).

## Задание 10. Поиск наибольшей последовательности нулей

Поиск наибольшей последовательности нулей в массиве — это алгоритм, который позволяет найти самую длинную последовательность нулей в данном массиве.

### Алгоритм

1. Создаем переменные для отслеживания текущей (**_currentCount_**) последовательности и максимальной (**_maxCount_**) последовательности нулей.
2. Пройдемся по всем элементам массива (строки), начиная с первого.
3. Если текущий элемент равен нулю, увеличим currentCount на 1.
4. Если текущий элемент не равен нулю, сбросим currentCount в 0.
5. После каждого шага 3 нужно проверить, является ли currentCount новым максимумом. Если да, обновляем значение maxCount. 
6. Повторяем шаги 2-4 для всех элементов массива. В конце процесса maxCount содержит длину наибольшей последовательности нулей.

#### Пример

Рассмотрим строку _"1000100100001"_.

currentCount = 0, maxCount = 0.
При встрече со второй 1, currentCount = 0, а maxCount = 3.
При встрече с последней 1, currentCount = 0, а maxCount = 4.

**_Ответ:_** 4
